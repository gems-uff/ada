/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package br.uff.ic.archd.db.dao;

import br.uff.ic.archd.javacode.JavaAbstract;
import br.uff.ic.archd.javacode.JavaAbstractExternal;
import br.uff.ic.archd.javacode.JavaClass;
import br.uff.ic.archd.javacode.JavaData;
import br.uff.ic.archd.javacode.JavaInterface;
import br.uff.ic.archd.javacode.JavaMethod;
import br.uff.ic.archd.javacode.JavaPrimitiveType;
import br.uff.ic.archd.javacode.JavaProject;
import br.uff.ic.archd.javacode.Parameter;
import java.io.File;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.LinkedList;
import java.util.List;

/**
 *
 * @author wallace
 */
public class HsqldbJavaMethodDao implements JavaMethodDao {

    private final static String DB_DIR = System.getProperty("user.home") + "/.archDB/METRIC_VALUE_DB_DIR/";
    private Connection connection;

    public HsqldbJavaMethodDao() {
        try {
            File file = new File(DB_DIR);
            if (!file.exists()) {
                file.mkdirs();

            }
            Class.forName("org.hsqldb.jdbcDriver");
            connection = DriverManager.getConnection("jdbc:hsqldb:file:" + DB_DIR, "archd", "123");
            DatabaseMetaData dbData = connection.getMetaData();
            ResultSet tables = dbData.getTables(null, null, "JAVA_METHODS", null);
            //System.out.println("NEXT "+tables.next());
            if (!tables.next()) {


                System.out.println("NAO POSSUI TABELA");
                Statement stm = connection.createStatement();

                stm.executeUpdate("create table JAVA_METHODS (id bigint GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), "
                        + "name varchar(1000),"
                        + "return_type varchar(1000),"
                        + "parameters varchar(3000),"
                        + "cyclomatic_complexity int,"
                        + "size_in_chars int,"
                        + "is_final boolean,"
                        + "is_static boolean,"
                        + "is_abstract boolean,"
                        + "is_synchronized boolean,"
                        + "is_private boolean,"
                        + "is_public boolean,"
                        + "is_protected boolean,"
                        + "change_internal_state boolean,"
                        + "change_internal_state_by_method_invocation boolean,"
                        + "internal_id int,"
                        + "interface_id bigint,"
                        + "class_id bigint);");
            } else {
                System.out.println("TABELA JAH EXISTE");
            }

            //stm.execute("SHUTDOWN");

        } catch (ClassNotFoundException e) {
            System.out.println("Erro ao carregar o driver JDBC. ");
        } catch (SQLException e) {
            System.out.println("Erro de SQL: " + e);
            //e.printStackTrace();
        } catch (Exception e) {
            System.out.println("ERRO " + e.getMessage());
        }


    }

    @Override
    public void save(JavaMethod javaMethod, boolean fromClass, long itemId) {
        try {
            Statement stm = connection.createStatement();
            if (fromClass) {
                System.out.println("insert into JAVA_METHODS (name ,"
                        + "return_type ,"
                        + "parameters ,"
                        + "cyclomatic_complexity ,"
                        + "size_in_chars ,"
                        + "is_final ,"
                        + "is_static ,"
                        + "is_abstract ,"
                        + "is_synchronized ,"
                        + "is_private ,"
                        + "is_public ,"
                        + "is_protected ,"
                        + "change_internal_state ,"
                        + "change_internal_state_by_method_invocation ,"
                        + "internal_id ,"
                        + "class_id )"
                        + " VALUES ('" + javaMethod.getName() + "','"
                        + javaMethod.getReturnType().getName() + "','"
                        + javaMethod.getParametersSignature() + "',"
                        + javaMethod.getCyclomaticComplexity() + ","
                        + javaMethod.getSizeInChars() + ","
                        + javaMethod.isFinal() + ","
                        + javaMethod.isStatic() + ","
                        + javaMethod.isAbstract() + ","
                        + javaMethod.isSynchronized() + ","
                        + javaMethod.isPrivate() + ","
                        + javaMethod.isPublic() + ","
                        + javaMethod.isProtected() + ","
                        + javaMethod.isChangeInternalState() + ","
                        + javaMethod.isChangeInternalStateByMethodInvocations() + ","
                        + javaMethod.getInternalID() + ","
                        + itemId + ""
                        + ");");
                stm.executeUpdate("insert into JAVA_METHODS (name ,"
                        + "return_type ,"
                        + "parameters ,"
                        + "cyclomatic_complexity ,"
                        + "size_in_chars ,"
                        + "is_final ,"
                        + "is_static ,"
                        + "is_abstract ,"
                        + "is_synchronized ,"
                        + "is_private ,"
                        + "is_public ,"
                        + "is_protected ,"
                        + "change_internal_state ,"
                        + "change_internal_state_by_method_invocation ,"
                        + "internal_id ,"
                        + "class_id )"
                        + " VALUES ('" + javaMethod.getName() + "','"
                        + javaMethod.getReturnType().getName() + "','"
                        + javaMethod.getParametersSignature() + "',"
                        + javaMethod.getCyclomaticComplexity() + ","
                        + javaMethod.getSizeInChars() + ","
                        + javaMethod.isFinal() + ","
                        + javaMethod.isStatic() + ","
                        + javaMethod.isAbstract() + ","
                        + javaMethod.isSynchronized() + ","
                        + javaMethod.isPrivate() + ","
                        + javaMethod.isPublic() + ","
                        + javaMethod.isProtected() + ","
                        + javaMethod.isChangeInternalState() + ","
                        + javaMethod.isChangeInternalStateByMethodInvocations() + ","
                        + javaMethod.getInternalID() + ","
                        + itemId + ""
                        + ");");
                //stm.execute("SHUTDOWN");
            } else {
                System.out.println("insert into JAVA_METHODS (name ,"
                        + "return_type ,"
                        + "parameters ,"
                        + "cyclomatic_complexity ,"
                        + "size_in_chars ,"
                        + "is_final ,"
                        + "is_static ,"
                        + "is_abstract ,"
                        + "is_synchronized ,"
                        + "is_private ,"
                        + "is_public ,"
                        + "is_protected ,"
                        + "change_internal_state ,"
                        + "change_internal_state_by_method_invocation ,"
                        + "internal_id ,"
                        + "interface_id )"
                        + " VALUES ('" + javaMethod.getName() + "','"
                        + javaMethod.getReturnType().getName() + "','"
                        + javaMethod.getParametersSignature() + "',"
                        + javaMethod.getCyclomaticComplexity() + ","
                        + javaMethod.getSizeInChars() + ","
                        + javaMethod.isFinal() + ","
                        + javaMethod.isStatic() + ","
                        + javaMethod.isAbstract() + ","
                        + javaMethod.isSynchronized() + ","
                        + javaMethod.isPrivate() + ","
                        + javaMethod.isPublic() + ","
                        + javaMethod.isProtected() + ","
                        + javaMethod.isChangeInternalState() + ","
                        + javaMethod.isChangeInternalStateByMethodInvocations() + ","
                        + javaMethod.getInternalID() + ","
                        + itemId + ""
                        + ");");
                stm.executeUpdate("insert into JAVA_METHODS (name ,"
                        + "return_type ,"
                        + "parameters ,"
                        + "cyclomatic_complexity ,"
                        + "size_in_chars ,"
                        + "is_final ,"
                        + "is_static ,"
                        + "is_abstract ,"
                        + "is_synchronized ,"
                        + "is_private ,"
                        + "is_public ,"
                        + "is_protected ,"
                        + "change_internal_state ,"
                        + "change_internal_state_by_method_invocation ,"
                        + "internal_id ,"
                        + "interface_id )"
                        + " VALUES ('" + javaMethod.getName() + "','"
                        + javaMethod.getReturnType().getName() + "','"
                        + javaMethod.getParametersSignature() + "',"
                        + javaMethod.getCyclomaticComplexity() + ","
                        + javaMethod.getSizeInChars() + ","
                        + javaMethod.isFinal() + ","
                        + javaMethod.isStatic() + ","
                        + javaMethod.isAbstract() + ","
                        + javaMethod.isSynchronized() + ","
                        + javaMethod.isPrivate() + ","
                        + javaMethod.isPublic() + ","
                        + javaMethod.isProtected() + ","
                        + javaMethod.isChangeInternalState() + ","
                        + javaMethod.isChangeInternalStateByMethodInvocations() + ","
                        + javaMethod.getInternalID() + ","
                        + itemId + ""
                        + ");");
            }
            ResultSet rs = stm.executeQuery("CALL IDENTITY();");
            long id = 0;
            if (rs.next()) {
                id = rs.getLong(1);
            }
            javaMethod.setId(id);
            System.out.println("Method ID: " + javaMethod.getId());
        } catch (SQLException e) {
            System.out.println("ERRO method: " + e.getMessage());
        }
    }

    @Override
    public List<JavaMethod> getAllJavaMethod(JavaProject javaProject) {
        List<JavaMethod> javaMethods = new LinkedList();
        try {
            Statement stm = connection.createStatement();
            ResultSet rs = stm.executeQuery("select * from JAVA_METHODS ;");
            int i = 0;
            while (rs.next()) {
                JavaData javaData = JavaDataHash.getInstance().getJavaData(rs.getString("return_type"));
                JavaMethod javaMethod = new JavaMethod(rs.getString("name"), javaData,
                        Boolean.valueOf(rs.getString("is_final")),
                        Boolean.valueOf(rs.getString("is_static")), Boolean.valueOf(rs.getString("is_abstract")),
                        Boolean.valueOf(rs.getString("is_synchronized")), Boolean.valueOf(rs.getString("is_private")),
                        Boolean.valueOf(rs.getString("is_public")), Boolean.valueOf(rs.getString("is_protected")),
                        Integer.valueOf(rs.getString("cyclomatic_complexity")), null);
                javaMethod.setId(Long.parseLong(rs.getString("id")));
                String parametersSignature = rs.getString("parameters");
                if (!parametersSignature.equals("")) {
                    String paramsArray[] = parametersSignature.split(";");
                    for (int j = 0; j < paramsArray.length; j++) {
                        String param[] = paramsArray[j].split(":");
                        JavaAbstract javaAbstract = javaProject.getClassByName(param[0]);
                        if (javaAbstract == null) {
                            JavaAbstractExternal javaAbstractExternal = javaProject.getJavaExternalClassByName(param[0]);
                            if (javaAbstractExternal == null) {
                                JavaPrimitiveType javaPrimitiveType = new JavaPrimitiveType(JavaPrimitiveType.getType(param[0]));
                                Parameter parameter = new Parameter(javaPrimitiveType, param[1]);
                                javaMethod.addParameter(parameter);
                            } else {
                                Parameter parameter = new Parameter(javaAbstractExternal, param[1]);
                                javaMethod.addParameter(parameter);
                            }
                        } else {
                            Parameter parameter = new Parameter(javaAbstract, param[1]);
                            javaMethod.addParameter(parameter);
                        }
                    }
                }
                javaMethods.add(javaMethod);
                i++;
            }
            //stm.execute("SHUTDOWN");
            //System.out.println("QUANTIDADE: " + i);
        } catch (Exception e) {
            System.out.println("ERRO method: " + e.getMessage());
        }
        return javaMethods;
    }

    @Override
    public List<JavaMethod> getJavaMethodsByInterfaceId(JavaProject javaProject, long id) {
        List<JavaMethod> javaMethods = new LinkedList();
        try {
            Statement stm = connection.createStatement();
            ResultSet rs = stm.executeQuery("select * from JAVA_METHODS where interface_id=" + id + ";");
            int i = 0;
            while (rs.next()) {
                JavaData javaData = javaProject.getClassByName(rs.getString("return_type"));
                if (javaData == null) {
                    if (JavaPrimitiveType.getType(rs.getString("return_type")) != 0) {
                        javaData = new JavaPrimitiveType(JavaPrimitiveType.getType(rs.getString("return_type")));
                    } else {
                        javaData = javaProject.getJavaExternalClassByName(rs.getString("return_type"));
                        if (javaData == null) {
                            javaData = new JavaAbstractExternal(rs.getString("return_type"));
                            javaProject.addExternalClass((JavaAbstractExternal) javaData);
                        }
                    }
                }
                JavaMethod javaMethod = new JavaMethod(rs.getString("name"), javaData,
                        Boolean.valueOf(rs.getString("is_final")),
                        Boolean.valueOf(rs.getString("is_static")), Boolean.valueOf(rs.getString("is_abstract")),
                        Boolean.valueOf(rs.getString("is_synchronized")), Boolean.valueOf(rs.getString("is_private")),
                        Boolean.valueOf(rs.getString("is_public")), Boolean.valueOf(rs.getString("is_protected")),
                        Integer.valueOf(rs.getString("cyclomatic_complexity")), null);

                javaMethod.setSizeInChars(Integer.valueOf(rs.getString("size_in_chars")));
                javaMethod.setChangeInternalState(Boolean.valueOf(rs.getString("change_internal_state")));
                javaMethod.setChangeInternalStateByMethodInvocations(Boolean.valueOf(rs.getString("change_internal_state_by_method_invocation")));
                String parameterString = rs.getString("parameters");
                if (!parameterString.equals("")) {
                    String parameters[] = parameterString.split(";");
                    for (int j = 0; j < parameters.length; j++) {
                        String parameter[] = parameters[j].split(":");
                        JavaData parameterType = javaProject.getClassByName(parameter[0]);
                        if (parameterType == null) {
                            if (JavaPrimitiveType.getType(parameter[0]) != 0) {
                                parameterType = new JavaPrimitiveType(JavaPrimitiveType.getType(parameter[0]));
                            } else {
                                parameterType = javaProject.getJavaExternalClassByName(parameter[0]);
                                if (parameterType == null) {
                                    parameterType = new JavaAbstractExternal(parameter[0]);
                                    javaProject.addExternalClass((JavaAbstractExternal) parameterType);
                                }
                            }

                        }
                        Parameter javaParameter = new Parameter(parameterType, parameter[1]);
                        javaMethod.addParameter(javaParameter);
                    }
                }

                javaMethod.setId(Long.parseLong(rs.getString("id")));
                javaMethods.add(javaMethod);
                i++;
            }
            //stm.execute("SHUTDOWN");
            //System.out.println("QUANTIDADE: " + i);
        } catch (Exception e) {
            System.out.println("ERRO method: " + e.getMessage());
        }
        return javaMethods;
    }

    @Override
    public List<JavaMethod> getJavaMethodsByClassId(JavaProject javaProject, long id) {
        List<JavaMethod> javaMethods = new LinkedList();
        try {
            Statement stm = connection.createStatement();
            ResultSet rs = stm.executeQuery("select * from JAVA_METHODS where class_id=" + id + ";");
            int i = 0;
            while (rs.next()) {
                System.out.println("Java method: " + rs.getString("name") + "   return type: " + rs.getString("return_type"));
                JavaData javaData = javaProject.getClassByName(rs.getString("return_type"));
                if (javaData == null) {
                    if (JavaPrimitiveType.getType(rs.getString("return_type")) != 0) {
                        javaData = new JavaPrimitiveType(JavaPrimitiveType.getType(rs.getString("return_type")));
                    } else {
                        javaData = javaProject.getJavaExternalClassByName(rs.getString("return_type"));
                        if (javaData == null) {
                            javaData = new JavaAbstractExternal(rs.getString("return_type"));
                            javaProject.addExternalClass((JavaAbstractExternal) javaData);
                        }
                    }
                }
                JavaMethod javaMethod = new JavaMethod(rs.getString("name"), javaData,
                        Boolean.valueOf(rs.getString("is_final")),
                        Boolean.valueOf(rs.getString("is_static")), Boolean.valueOf(rs.getString("is_abstract")),
                        Boolean.valueOf(rs.getString("is_synchronized")), Boolean.valueOf(rs.getString("is_private")),
                        Boolean.valueOf(rs.getString("is_public")), Boolean.valueOf(rs.getString("is_protected")),
                        Integer.valueOf(rs.getString("cyclomatic_complexity")), null);
                String parameterString = rs.getString("parameters");
                javaMethod.setSizeInChars(Integer.valueOf(rs.getString("size_in_chars")));
                javaMethod.setChangeInternalState(Boolean.valueOf(rs.getString("change_internal_state")));
                javaMethod.setChangeInternalStateByMethodInvocations(Boolean.valueOf(rs.getString("change_internal_state_by_method_invocation")));
                if (!parameterString.equals("")) {
                    System.out.println("parameter string: "+parameterString);
                    String parameters[] = parameterString.split(";");
                    for (int j = 0; j < parameters.length; j++) {
                        String parameter[] = parameters[j].split(":");
                        JavaData parameterType = javaProject.getClassByName(parameter[0]);
                        if (parameterType == null) {
                            if (JavaPrimitiveType.getType(parameter[0]) != 0) {
                                parameterType = new JavaPrimitiveType(JavaPrimitiveType.getType(parameter[0]));
                            } else {
                                parameterType = javaProject.getJavaExternalClassByName(parameter[0]);
                                if (parameterType == null) {
                                    parameterType = new JavaAbstractExternal(parameter[0]);
                                    javaProject.addExternalClass((JavaAbstractExternal) parameterType);
                                }
                            }
                        }
                        Parameter javaParameter = new Parameter(parameterType, parameter[1]);
                        javaMethod.addParameter(javaParameter);
                    }
                }
                javaMethod.setId(Long.parseLong(rs.getString("id")));
                javaMethods.add(javaMethod);
                i++;
            }
            //stm.execute("SHUTDOWN");
            //System.out.println("QUANTIDADE MÃ©todos  " + i);
        } catch (Exception e) {
            System.out.println("ERRO method: " + e.getMessage());
        }
        return javaMethods;
    }

    public void getJavaMethods(JavaProject javaProject, JavaAbstract javaAbstract) {
        try {
            Statement stm = connection.createStatement();
            ResultSet rs = null;
            if (javaAbstract.getClass() == JavaClass.class) {
                rs = stm.executeQuery("select * from JAVA_METHODS where class_id=" + javaAbstract.getId() + ";");
            } else {
                rs = stm.executeQuery("select * from JAVA_METHODS where interface_id=" + javaAbstract.getId() + ";");
            }
            int i = 0;
            while (rs.next()) {
                JavaData javaData = javaProject.getClassByName(rs.getString("return_type"));
                if (javaData == null) {
                    javaData = javaProject.getJavaExternalClassByName(rs.getString("return_type"));
                    if (javaData == null) {
                        javaData = new JavaPrimitiveType(JavaPrimitiveType.getType(rs.getString("return_type")));
                    }
                }
                JavaMethod javaMethod = new JavaMethod(rs.getString("name"), javaData,
                        Boolean.valueOf(rs.getString("is_final")),
                        Boolean.valueOf(rs.getString("is_static")), Boolean.valueOf(rs.getString("is_abstract")),
                        Boolean.valueOf(rs.getString("is_synchronized")), Boolean.valueOf(rs.getString("is_private")),
                        Boolean.valueOf(rs.getString("is_public")), Boolean.valueOf(rs.getString("is_protected")),
                        Integer.valueOf(rs.getString("cyclomatic_complexity")), null);
                String parameterString = rs.getString("parameters");
                if (!parameterString.equals("")) {
                    String parameters[] = parameterString.split(";");
                    for (int j = 0; j < parameters.length; j++) {
                        String parameter[] = parameters[j].split(":");
                        JavaData parameterType = javaProject.getClassByName(parameter[0]);
                        if (parameterType == null) {
                            parameterType = javaProject.getJavaExternalClassByName(parameter[0]);
                            if (parameterType == null) {
                                parameterType = new JavaPrimitiveType(JavaPrimitiveType.getType(parameter[0]));
                            }
                        }
                        Parameter javaParameter = new Parameter(parameterType, parameter[1]);
                        javaMethod.addParameter(javaParameter);
                    }
                }
                javaMethod.setId(Long.parseLong(rs.getString("id")));
                if (javaAbstract.getClass() == JavaClass.class) {
                    ((JavaClass) javaAbstract).addMethod(javaMethod);
                } else {
                    ((JavaInterface) javaAbstract).addJavaMethod(javaMethod);
                }
                i++;
            }
            //stm.execute("SHUTDOWN");
            //System.out.println("QUANTIDADE: " + i);
        } catch (Exception e) {
            System.out.println("ERRO method: " + e.getMessage());
        }
    }
}
